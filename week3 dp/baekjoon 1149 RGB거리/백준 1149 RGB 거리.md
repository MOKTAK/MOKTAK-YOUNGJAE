# 백준 1149 : RGB 거리

#### Date : 21/10/07

#### Lang : Python

#### Question : [백준 1149](https://www.acmicpc.net/problem/1149)

## 1차 답안 

```python
n = int(input())
cost = []
for i in range(n):
    cost.append(list(map(int, input().split())))

dp = [0]*n
temp = min(cost[0])
index = cost[0].index(temp)
dp[0] = index

for i in range(1, n):
    temp = min(cost[i])
    index = cost[i].index(temp)
    if index == dp[i-1]:
        if index == 0:
            temp = cost[i][1] if cost[i][1] < cost[i][2] else cost[i][2]
            index = cost[i].index(temp)
        elif index == 1:
            temp = cost[i][0] if cost[i][0] < cost[i][2] else cost[i][2]
            index = cost[i].index(temp)
        elif index == 2:
            temp = cost[i][1] if cost[i][1] < cost[i][0] else cost[i][0]
            index = cost[i].index(temp)
    dp[i] = index


sum = 0
for i in range(n):
    sum += cost[i][dp[i]]

print(sum)

```

진짜 무지성 코딩. ㅎ 
답도 당연히 틀렸다.  
n번째 집을 색칠한다고 했을때 인접한 집들과는 반드시 다른 색을 칠해야한다는 조건이 주요하다.  
그렇기 때문에 한 리스트에서 가장 작은 수만 더한다고해서, 반드시 최소 값이 나오지는 않는데 이걸 간과했다;; 

## 최종 답안

```python
n = int(input())
cost = []
for i in range(n):
    cost.append(list(map(int, input().split())))

for i in range(1, n):
    cost[i][0] = min(cost[i-1][1], cost[i-1][2]) + cost[i][0]
    cost[i][1] = min(cost[i-1][0], cost[i-1][2]) + cost[i][1]
    cost[i][2] = min(cost[i-1][0], cost[i-1][1]) + cost[i][2]

print(min(cost[n-1][0], cost[n-1][1], cost[n-1][2]))

```

사실상 클론 코딩

0,1,2는 각각 빨강, 초록, 파랑 집을 의미한다.   
for 문으로 두번째 집부터 시작해서, 빨간집, 초록집, 파랑집일 경우를 계산해준다.  
이 때 이전의 색을 제외한 색의 최소 값을 더해주는걸 반복한다.  
이렇게 하면, 최종적으로 빨강,초록,파랑 색을 선택한 모든 경우에서 가장 최소값만을 더해져서 확인할 수 있고,  
그 중에서 가장 최소값을 출력한다. 

도대체 이런건 어떻게 푸냐~ dp 때려치고 싶을지도?